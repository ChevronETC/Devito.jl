var documenterSearchIndex = {"docs":
[{"location":"#Devito.jl","page":"Devito.jl","title":"Devito.jl","text":"","category":"section"},{"location":"","page":"Devito.jl","title":"Devito.jl","text":"Package Devito is a Julia wrapper for the Devito stencil compiler. The procedure for constructing a stencil operator consists of five parts:","category":"page"},{"location":"","page":"Devito.jl","title":"Devito.jl","text":"Construction of a Grid object containing grid size and spacing information on which the stencil will operate\nConstruction of TimeFunction or Function objects that hold the actual arrays on which the stencil will operate\nConstruction of SparseTimeFunction objects that hold source and receiver data for injection and retrieval during the stencil operation\nConstruction of Eqn objects (equation objects) that specify the equations that the stencil operator will carry out\nConstruction of the operator object which generates the low level C code fo rthe stencil operator","category":"page"},{"location":"","page":"Devito.jl","title":"Devito.jl","text":"Following this the operator may be executed. An example of these five steps is detailed below","category":"page"},{"location":"","page":"Devito.jl","title":"Devito.jl","text":"Definition of the Grid object","category":"page"},{"location":"","page":"Devito.jl","title":"Devito.jl","text":"The Grid object is specified by initializing extent, spacing, and origin tuples in the constructor. Dimension objects contain the  abstract spacing variables used by SymPy in specifying abstract equations in the stencil definition","category":"page"},{"location":"","page":"Devito.jl","title":"Devito.jl","text":"dt=1.\nshpe=(20,20)\nspacing=(5.,5.)\norigin=(0.,0.)\nextent=(shpe.-1).*spacing\nspacet=Constant(name=\"h_t\", dt) \nt=TimeDimension(name=\"t\",spacing=spacet)\nspacex=Constant(name=\"h_x\", spacing[1]) \nx=SpaceDimension(name=\"x\",spacing=spacex)\nspacez=Constant(name=\"h_z\", spacing[2])\nz=SpaceDimension(name=\"z\",spacing=spacez)\ngrid=Grid(extent=extent, shape=shpe, origin=origin, dimensions=(x,z), time_dimension=t)","category":"page"},{"location":"","page":"Devito.jl","title":"Devito.jl","text":"Note that he dimensions are passed in column-major order, in alignment with the Devito Python implementation. For all other tuples involving dimensions in Julia, the ordering is row-major.","category":"page"},{"location":"","page":"Devito.jl","title":"Devito.jl","text":"Construction of time and space functions","category":"page"},{"location":"","page":"Devito.jl","title":"Devito.jl","text":"Parameters on the grid are specified using Function objects, while time dependent fields are specified using TimeFunction objects,  as in this 2D elastic example:","category":"page"},{"location":"","page":"Devito.jl","title":"Devito.jl","text":"so=4\nbx=Devito.Function(name= \"bx\" ,grid=grid, staggered=x,     space_order=so)\nbz=Devito.Function(name= \"bz\" ,grid=grid, staggered=z,     space_order=so)\nc11=Devito.Function(name=\"c11\",grid=grid, space_order=so)\nc33=Devito.Function(name=\"c33\",grid=grid, space_order=so)\nc55=Devito.Function(name=\"c55\",grid=grid, staggered=(x,z), space_order=so)\nc13=Devito.Function(name=\"c13\",grid=grid, space_order=so)\ndata(bx).=mp[:,:,1]\ndata(bz).=mp[:,:,2]\ndata(c11).=mp[:,:,3]\ndata(c33).=mu[:,:,2]\ndata(c55).=mp[:,:,4]\ndata(c13).=mp[:,:,5]\nvx=TimeFunction(name=\"vx\",      grid=grid,space_order=so, staggered=x, time_order=1)\nvz=TimeFunction(name=\"vz\",      grid=grid,space_order=so, staggered=z, time_order=1)\ntauxx=TimeFunction(name=\"tauxx\",grid=grid,space_order=so,                  time_order=1)\ntauzz=TimeFunction(name=\"tauzz\",grid=grid,space_order=so,                  time_order=1)\ntauxz=TimeFunction(name=\"tauxz\",grid=grid,space_order=so, staggered=(x,z), time_order=1)","category":"page"},{"location":"","page":"Devito.jl","title":"Devito.jl","text":"In this example, the data() function returns a view to the Function's internal data, which is then initialized from an externally defined arrays mp and mu.","category":"page"},{"location":"","page":"Devito.jl","title":"Devito.jl","text":"Construction of  SparseTimeFunctions","category":"page"},{"location":"","page":"Devito.jl","title":"Devito.jl","text":"SparseTimeFunctions are used to inject source and retrieve receiver information during the stencil operations","category":"page"},{"location":"","page":"Devito.jl","title":"Devito.jl","text":"src = SparseTimeFunction(name=\"src\", grid=grid, npoint=1, nt=nt)\nsrc_coords = coordinates(src)\nsrc_coords .= [625.0; 5.0]\nsrc_data = data(src)\nsrc_data.= ricker(nt,dt,f0)\nsrc_term = inject(src; field=forward(tauxx), expr=src)","category":"page"},{"location":"","page":"Devito.jl","title":"Devito.jl","text":"In this example, the source is created with an external function ricker(), which is then used to initialize the SparseTimeFunction data that will be injected into the time function forward(tauxx)","category":"page"},{"location":"","page":"Devito.jl","title":"Devito.jl","text":"Construction of  stencil equations","category":"page"},{"location":"","page":"Devito.jl","title":"Devito.jl","text":"Stencil equations are created using the Eqn constructor ","category":"page"},{"location":"","page":"Devito.jl","title":"Devito.jl","text":"eqvx = Eq(forward(vx), vx + dt*bx*dx(tauxx) + dt*bx*dz(tauxz, x0=z) - dt*damp*vx)\neqvz = Eq(forward(vz), vz + dt*bz*dx(tauxz, x0=x) + dt*bz*dz(tauzz) - dt*damp*vz)","category":"page"},{"location":"","page":"Devito.jl","title":"Devito.jl","text":"In this particular fragment from an elastic 2D example, damp is an externally defined array for damping at the boundaries, vx and vz are particle velocities, and the tau variables are the stresses ","category":"page"},{"location":"","page":"Devito.jl","title":"Devito.jl","text":"Construction of the operator","category":"page"},{"location":"","page":"Devito.jl","title":"Devito.jl","text":"Construction of the operator requires a list containing all objects created using the inject(), interpolate(), and Eq() functions:","category":"page"},{"location":"","page":"Devito.jl","title":"Devito.jl","text":"op=Operator(op_list, subs=spacing_map(grid))\napply(op)","category":"page"},{"location":"","page":"Devito.jl","title":"Devito.jl","text":"where op_list contains the objects comprising the stencil.","category":"page"},{"location":"","page":"Devito.jl","title":"Devito.jl","text":"In general, the wrapping of Devito functionality uses the same function and argument names as in the original Python implementation, with  python class members being accessed in Julia through functions having the same name as the member, and taking the class object as the first argument.","category":"page"},{"location":"","page":"Devito.jl","title":"Devito.jl","text":"For more details, please refer to the Devito website https://github.com/devitocodes/devito","category":"page"}]
}
